require 'io'
require 'os'
require 'hashmap'
-- import json
local DEFAULT_PROCPATH = '/proc'

local head = [[{"version":1,"click_events":true,"stop_signal":0,"cont_signal":0}
[]]
print(head)
os.sleep(1)

-- function ipc_query(req="command", msg="")
--     ans = popen("i3-msg -t " + req + " " +  msg).readlines()[0]
--     return json.loads(ans)
local function sum(...: varargs)
  local s: integer
  for i, v in ipairs(...) do -- iterate over all arguments
    s = s + v
  end
  return s
end

local last_idle = 0
local last_total = 0
local function get_cpu_usage()
    local _fd = assert(io.open(DEFAULT_PROCPATH.. '/stat', 'r'))
    local line = _fd:read("l")
    local pattern = string.format("cpu+%s",
      -- string.rep('%s+(%d+)', 10)
      string.rep('%s+(%d+)', 7)
      )

    local s, fields = line:match(pattern)
    local idle, total = tointeger(fields[4]), sum(fields)
    local idle_delta, total_delta = idle - last_idle, total - last_total
    last_idle, last_total = idle, total
    local utilisation = 100.0 * (1.0 - idle_delta / total_delta)
    _fd:close()
    return utilisation
end

local function get_mem_usage()
  local meminfo: hashmap(string, integer)
    local f = assert(io.open(DEFAULT_PROCPATH.. '/meminfo', 'r'))
    for line in f:lines() do
        local s, matches = line:match('(%w+):%s+(%d+)%s+(%w+)')
        local key, value, unit = matches[1], matches[2]
        local match, _ = (string.match(value, '%d+'))
        if match then
          meminfo[key] = tointeger(value)
        end
        if key == 'MemTotal' then
        end
    end
    f:close()
    local percentage_used = tointeger( ( meminfo['MemTotal'] - (
        meminfo['Buffers'] + meminfo['Cached'] + meminfo['MemFree']
    ) ) / meminfo['MemTotal'] * 100 )
    return percentage_used
end

-- def get_width():
--     for w in ipc_query(req="get_workspaces"):
--         if w['focused']:
--             return (w['rect']['width'])

local function get_spacer()
    -- local width = get_width()
  -- local text: stringbuilder
  -- for i = 1, 110, 1 do
  --   -- text:write(i)
  --   text:write(1)
  -- end
  return string.format(
    [[{"full_text": "%s", "name" : "spacer"}]],
    -- text)
    string.rep(' ', 110))
end

local spacer = get_spacer()

local function get_status()
  local cpu = string.format(
    '{"full_text": " cpu %02d%% ", "name" : "cpu"}',
    get_cpu_usage())
  local memory = string.format(
    '{"full_text": " mem %02d%% ", "name" : "mem"}',
    get_mem_usage())
  local module_center = string.format(
    [[{"full_text": "%s", "name" : "datetime",
    "align":"center", "min_width":2160}]],
    os.date('%Y-%m-%d %a %H:%M:%S'))
  -- local status:[]string = {
  --      -- datetime,
  --      -- spacer,
  --      -- cpu,
  --      memory,
  --   }
  -- local status = string.format(
  --   '%s,\n', memory)
  local status: stringbuilder
  status:write('[')

  status:write(module_center, ',')
  -- status:write(spacer, ',')
  status:write(cpu, ',')
  status:write(memory)

  status:write('],\n')
    return status
end

while true do
    local status = get_status()
    io.stdout:write(status)
    io.stdout:flush()
    os.sleep(1)
end
